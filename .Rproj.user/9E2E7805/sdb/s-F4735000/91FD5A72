{
    "contents" : "---\ntitle: \"MLE in R\"\nauthor: \"Alexander Forrence\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Vignette Title}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\nFirst, we'll load some of the necessary packages:\n\n```{r pkgs, message=FALSE,warning=FALSE}\nlibrary(lme4)\nlibrary(bbmle)\nlibrary(optimx)\nlibrary(psyphy)\nlibrary(lattice)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n```\nFor example, to read in the csv containing the data for the free RT...\n\n```{r}\nfree_rt <- read.csv(system.file(\"extdata\", \"bigrt.csv\", package = 'multimles'),\n                    header = FALSE,\n                    col.names = c('id', 'RT', 'reachDir', 'hit'))\n```\n\nand for the forced RT,\n\n```{r}\nforced_rt <- read.csv(system.file(\"extdata\", \"bigtr.csv\", package = 'multimles'), \n                      header = FALSE,\n                      col.names = c('id', 'RT', 'reachDir', 'hit'))\n```\n\nTo clean up the data a bit, try things like\n\n```{r, eval = FALSE}\n    free_rt <- free_rt[complete.cases(free_rt),]\n    free_rt <- free_rt[!(free_rt$RT > 0.5),]\n    free_rt <- free_rt[!(free_rt$RT < 0),]\n    # Should have 1860 obs. left over (check with str())\n```\n\nOr (in `dplyr` syntax):\n```{r}\nfree_rt <- free_rt %>% filter(!is.nan(reachDir), RT < 0.5, RT > 0)\nforced_rt <- forced_rt %>% filter(!is.nan(reachDir), RT < 0.5, RT > 0)\n```\n\nAlternatives are left as an exercise to the reader.\n\n## MLE\nThere were eight targets in this experiment. The objective function in `MATLAB` is specified as:\n\n> LL = @(params) -sum(hit.*log((1/8+asymptErr*normcdf(RT,params(1),params(2))*7/8)) + (1-hit).*log(1-(1/8+asymptErr*normcdf(RT,params(1),params(2))*7/8)));\n\nWhere `asymptErr` was the upper asymptote to the probit curve (starting value of 0.9), `params(1)` was the mean (start 0.3), and `params(2)` was the sd (start 0.1).\n\nA way to do it in R is with the `bbmle` package, a wrapper around the `mle`? function plus a number of very useful helper functions.\n\n```{r}\nllsig <- function(mu, sigma, asymptErr, rt, hit, Ntargs){\n    p1 <- log(1/Ntargs + asymptErr * pnorm(rt, mu, sigma)*(1 - 1/Ntargs))\n    p2 <- log(1 - (1/Ntargs + asymptErr * pnorm(rt, mu, sigma) * (1 - 1/Ntargs)))\n    -sum(hit %*% p1 + (1 - hit) %*% p2)\n}\n    \nstart_vals <- list(mu = 0.3, sigma = 0.1, asymptErr = 0.9)\nsubdat <- dplyr::filter(forced_rt, id == 5)\nmod1 <- mle2(llsig,\n            start = start_vals, \n            method = \"BFGS\", \n            optimizer = \"optim\",\n            data = list(rt = subdat$RT, hit = subdat$hit),\n            fixed = list(Ntargs = 8))\n```\n    \nIt takes some work to get answers out of `mle2`, and the optimizers in R aren't as robust as MATLAB's (at least I've heard).\n\nInterpretation isn't as direct, but this sort of thing can be fit with `lme4`.\n\n```{r,warning=FALSE,message=FALSE}\nmlme <- glmer(hit ~ RT + (1|id), \n              data = forced_rt, \n              family = binomial(link = mafc.probit(8)))\n    mlme2 <- update(mlme, .~. + (0 + RT|id)) # enforcing correlation doesn't work\n    anova(mlme, mlme2)\n    lmeprof2 <- profile(mlme2)\n    \n    xyplot(lmeprof2)\n```\n",
    "created" : 1450753469754.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2482616668",
    "id" : "91FD5A72",
    "lastKnownWriteTime" : 1450755811,
    "path" : "~/Documents/BLAM/multimles/vignettes/MLEs.Rmd",
    "project_path" : "vignettes/MLEs.Rmd",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_markdown"
}